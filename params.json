{"name":"obs","tagline":"observable properties done right","body":"# Synopsis\r\n\r\n**obs** is a powerful implementation of observable properties that can be used on both the client-side and the server-side.\r\n\r\nTogether with [rivets.js](http://rivetsjs.com) it can serve as a lightweight alternative to [Knockout.js](http://knockoutjs.com).\r\n\r\n[![browser support](https://ci.testling.com/pluma/obs.png)](https://ci.testling.com/pluma/obs)\r\n\r\n[![Build Status](https://travis-ci.org/pluma/obs.png?branch=master)](https://travis-ci.org/pluma/obs) [![Coverage Status](https://coveralls.io/repos/pluma/obs/badge.png?branch=master)](https://coveralls.io/r/pluma/obs?branch=master) [![NPM version](https://badge.fury.io/js/obs.png)](http://badge.fury.io/js/obs) [![Dependencies](https://david-dm.org/pluma/obs.png)](https://david-dm.org/pluma/obs)\r\n\r\n# Install\r\n\r\n## Node.js\r\n\r\n### With NPM\r\n\r\n```sh\r\nnpm install obs\r\n```\r\n\r\n### From source\r\n\r\n```sh\r\ngit clone https://github.com/pluma/obs.git\r\ncd obs\r\nnpm install\r\nmake && make dist\r\n```\r\n\r\n## Browser\r\n\r\n### With component\r\n\r\n```sh\r\ncomponent install pluma/obs\r\n```\r\n\r\n[Learn more about component](https://github.com/component/component).\r\n\r\n### With a CommonJS module loader\r\n\r\nDownload the [latest minified CommonJS release](https://raw.github.com/pluma/obs/master/dist/obs.min.js) and add it to your project.\r\n\r\nMake sure you also have a compatible copy of [sublish](https://github.com/pluma/sublish).\r\n\r\n[Learn more about CommonJS modules](http://wiki.commonjs.org/wiki/Modules/1.1).\r\n\r\n### With an AMD module loader\r\n\r\nDownload the [latest minified AMD release](https://raw.github.com/pluma/obs/master/dist/obs.amd.min.js) and add it to your project.\r\n\r\nMake sure you also have a compatible copy of [sublish](https://github.com/pluma/sublish).\r\n\r\n[Learn more about AMD modules](http://requirejs.org/docs/whyamd.html).\r\n\r\n### As standalone bundle\r\n\r\nGet the [latest distribution bundle](https://raw.github.com/pluma/obs/master/dist/obs.all.min.js) (~3.7 kB minified or ~1.2 kB gzipped, includes [sublish 0.4.5](https://github.com/pluma/sublish/tree/0.4.5)) and download it to your project.\r\n\r\n```html\r\n<script src=\"/your/js/path/obs.all.min.js\"></script>\r\n```\r\n\r\nThis makes the `obs` module available in the global namespace.\r\n\r\nIf you are already using `sublish` in your project, you can download the [latest minified standalone release](https://raw.github.com/pluma/obs/master/dist/obs.globals.min.js) (~3.2 kB minified or ~1.1 kB gzipped) instead.\r\n\r\n# Basic usage example with node.js\r\n\r\n```javascript\r\nvar obs = require('obs');\r\nvar x = obs.prop(2),\r\n    y = obs.prop(5),\r\n    sum = obs.computed(function() {\r\n        return x() + y();\r\n    }, [x, y]),\r\n    product = obs.computed(function() {\r\n        return x() * y();\r\n    }, [x, y]);\r\n\r\nconsole.log('sum is currently ' + sum());\r\n// 'sum is currently 7'\r\nconsole.log('product is currently ' + product());\r\n// 'product is currently 10'\r\n\r\nsum.subscribe(function(value, old) {\r\n    console.log('sum is now ' + value + ' (was: ' + old + ')');\r\n});\r\nproduct.subscribe(function(value, old) {\r\n    console.log('product is now ' + value + ' (was: ' + old + ')');\r\n});\r\n\r\nx(3);\r\n// 'sum is now 8 (was: 7)'\r\n// 'product is now 15 (was: 10)'\r\nconsole.log('sum is currently ' + sum());\r\n// 'sum is currently 8'\r\ny(8);\r\n// 'sum is now 11 (was: 8)'\r\n// 'product is now 24 (was: 15)'\r\n```\r\n\r\n# Example with writable computed observables\r\n\r\n```javascript\r\nvar obs = require('obs');\r\nvar firstname = obs.prop('John'),\r\n    lastname = obs.prop('Doe'),\r\n    fullname = obs.computed({\r\n        compute: function() {\r\n            return firstname() + ' ' + lastname();\r\n        },\r\n        write: function(value) {\r\n            var tokens = (value || '').split(' ');\r\n            firstname(tokens[0]);\r\n            lastname(tokens.slice(1).join(' '));\r\n        },\r\n        watch: [firstname, lastname]\r\n    });\r\nconsole.log(fullname()); // John Doe\r\nfullname('Konrad von Zuse');\r\nconsole.log(firstname()); // Konrad\r\nconsole.log(lastname()); // von Zuse\r\n```\r\n\r\n# Client-side example with [rivets.js](http://rivetsjs.com) data-binding\r\n\r\nTry it on [jsfiddle](http://jsfiddle.net/QdLxc/6/).\r\n\r\n## HTML\r\n\r\n```html\r\n<div id=\"view\">\r\n    <label>\r\n        Your name:\r\n        <input data-rv-value=\"user.name\"/>\r\n    </label>\r\n    <div data-rv-bgcolor=\"color\">\r\n        Hello <span data-rv-text=\"user.name\"></span>!<br>\r\n        The current UNIX time is: <span data-rv-text=\"now\"></span>\r\n    </div>\r\n</div>\r\n```\r\n\r\n## CSS\r\n\r\n```css\r\n#view {\r\n    font: 16px Verdana, Arial, sans-serif;\r\n}\r\n#view div {\r\n    padding: 10px;\r\n}\r\n```\r\n\r\n## JavaScript\r\n\r\n### Utilities\r\n\r\n```javascript\r\nvar colors = [\r\n    'rgba(255,0,0,0.5)', 'rgba(255,255,0,0.5)',\r\n    'rgba(0,255,0,0.5)', 'rgba(0,255,255,0.5)',\r\n    'rgba(0,0,255,0.5)', 'rgba(255,0,255,0.5)'\r\n];\r\nfunction resolveKeypath(obj, keypath) {\r\n    keypath.split('.').forEach(function(key) {\r\n        if (key) {\r\n            obj = obj[key];\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n```\r\n\r\n### Rivets.js adapter and configuration\r\n```javascript\r\nrivets.configure({\r\n    prefix: 'rv',\r\n    adapter: {\r\n        subscribe: function(obj, keypath, callback) {\r\n            resolveKeypath(obj, keypath).subscribe(callback);\r\n        },\r\n        unsubscribe: function(obj, keypath, callback) {\r\n            resolveKeypath(obj, keypath).unsubscribe(callback);\r\n        },\r\n        read: function(obj, keypath) {\r\n            return resolveKeypath(obj, keypath)();\r\n        },\r\n        publish: function(obj, keypath, value) {\r\n            resolveKeypath(obj, keypath)(value);\r\n        }\r\n    }\r\n});\r\n\r\nrivets.binders.bgcolor = function(el, value) {\r\n    el.style.backgroundColor = value;\r\n};\r\n```\r\n\r\n### ViewModel (using obs.js)\r\n\r\n```javascript\r\nvar viewModel = {\r\n    now: obs.prop(+new Date()),\r\n    color: obs.prop(colors[0]),\r\n    user: {\r\n        name: obs.prop('User')\r\n    }\r\n};\r\n\r\nvar view = rivets.bind($('#view'), viewModel);\r\n\r\nsetInterval(function() {\r\n    viewModel.now(+new Date());\r\n    viewModel.color(colors[\r\n        Math.floor(Math.random() * colors.length)\r\n    ]);\r\n}, 3000);\r\n```\r\n\r\n# API\r\n\r\n## obs: Abstract observables\r\n\r\nThis provides the base functionality for observables. You probably want to use `obs.prop` and `obs.computed` instead of calling `obs` directly.\r\n\r\n### obs(options)\r\n\r\nCreates an observable.\r\n\r\n#### options.context (optional)\r\n\r\nThe context the observable's `read` and `write` functions will be executed in.\r\n\r\nDefaults to the observable instance if not explicitly set.\r\n\r\n#### options.read:Function and options.write:Function (optional)\r\n\r\nThe functions to be called when the observable is read from or written to.\r\n\r\nAn error will be raised if the observable is read from but no `read` function was defined, or if it is written to and no `write` function was defined.\r\n\r\n#### options.watched:Array (optional)\r\n\r\nAn array of objects this observable subscribes to. If the value is not an array, it will be wrapped in one. Each object should have a `subscribe` method and (optionally) an `unsubscribe` method.\r\n\r\n#### options.onNotify:Function (optional)\r\n\r\nFunction to be called when an object the observable is watching changes. Defaults to the observable's `notify` method, effectively turning the observable into a relay.\r\n\r\n### obs#()\r\n\r\nCalls the observable's `read` function with its `context`.\r\n\r\n### obs#(value)\r\n\r\nCalls the observable's `write` function with its `context` and the given `value`.\r\n\r\n### obs#subscribe(callback:Function)\r\n\r\nAdds the given callback function to this observable's list of subscribers.\r\n\r\nThe callback will be called with the observable's new and old value as its arguments whenever the observable's value is updated (even if the new value is equal to the old value).\r\n\r\n### obs#unsubscribe(callback:Function):Boolean\r\n\r\nRemoves the given callback function from this observable's list of subscribers. The callback will no longer be called when the observable's value changes.\r\n\r\nReturns `false` if the callback could not be found in the list of subscribers or `true` otherwise.\r\n\r\n**NOTE:** Remember to use the exact function that was passed to `obs#subscribe`.\r\n\r\n### obs#peek()\r\n\r\nReturns the observable's current value without invoking its `read` function.\r\n\r\n### obs#commit()\r\n\r\nSets the observable's initial value to its current value and clears its `dirty` flag.\r\n\r\n### obs#reset()\r\n\r\nResets the observable to its initial value (or `undefined`), then calls `notify()`.\r\n\r\n### obs#notify()\r\n\r\nUpdates the observable's `dirty` flag, then notifies all subscribers with the its current and previous value.\r\n\r\n### obs#watch(dependencies…)\r\n\r\nAdds the given dependencies to this observable. Each dependency should have a `subscribe` and `unsubscribe` method. Whenever one of the dependencies changes, this observable's `onNotify` function will be called.\r\n\r\n### obs#unwatch(dependencies…)\r\n\r\nRemoves the given dependencies by calling their `unsubscribe` methods. The observable will no longer be notified when their values change.\r\n\r\n### obs#dismiss()\r\n\r\nRemoves all of the observable's dependencies. Equivalent to calling `obs#unwatch` for each dependency.\r\n\r\n### obs.fn\r\n\r\nAn object containing attributes that will be applied to new observables.\r\n\r\n## obs.prop: Observable properties\r\n\r\nThis provides a simple wrapper around `obs` useful for observables that should just act as a single value storage.\r\n\r\n### obs.prop([initialValue])\r\n\r\nCreates an observable property (optionally initialized with the given value).\r\n\r\n### obs.prop#()\r\n\r\nReturns the property's current value.\r\n\r\n### obs.prop#(newValue)\r\n\r\nSets the property's current value to `newValue` and notifies all subscribers.\r\n\r\n## obs.computed: Computed observables\r\n\r\nThis provides a simple wrapper around `obs` to create observables that depend on other observables and have values that should be computed dynamically, e.g. composite values of other observables.\r\n\r\n### obs.computed(compute:Function, [write:Function], [watch:Array])\r\n\r\nCreates a computed observable observable. The observable's value will be set to the return value of the given function `compute` and updated whenever any of the `watch` functions changes.\r\n\r\nIf `write` is passed, that function will be used when the computed observable is passed a value.\r\n\r\nThe list of `watch` functions can be an array containing any kind of object that supports the `subscribe` and (optionally) `unsubscribe` methods (e.g. an instance of `sublish.PubSub`).\r\n\r\n### obs.computed(options)\r\n\r\nCreates a computed observable property with the given options.\r\n\r\n#### options.compute:Function (optional)\r\n\r\nThe function this computed observable will use to generate its value. If this option is not provided, the observable will be write-only.\r\n\r\n#### options.write:Function (optional)\r\n\r\nThe function this computed observable will use when it is passed a value. If this option is not provided, the observable will be read-only.\r\n\r\n#### options.watch:Array (optional)\r\n\r\nSee above. This option has no effect if no `read` function is provided. If a single object is passed instead of an array, the object will automatically be wrapped in an array.\r\n\r\n#### options.context (optional)\r\n\r\nThe context the `compute` and `write` functions will be executed in. Defaults to the computed observable itself.\r\n\r\n### obs.computed#()\r\n\r\nReturns the computed property's current value. For lazy computed observables, this will trigger the function evaluation and notify any subscribers.\r\n\r\n### obs.computed.lazy(compute:Function, [write:Function], [watched:Array])\r\n\r\nSee `obs.computed(…)`. The created observable will only call its `compute` function to update its value when it is explicitly read from.\r\n\r\n### obs.computed.lazy(options)\r\n\r\nSee `obs.computed(options)` and above.\r\n\r\n# Acknowledgements\r\n\r\nThis library was heavily inspired by [Steve Sanderson's knockout.js project](https://github.com/SteveSanderson/knockout).\r\n\r\n# Unlicense\r\n\r\nThis is free and unencumbered public domain software. For more information, see http://unlicense.org/ or the accompanying [UNLICENSE](https://github.com/pluma/obs/blob/master/UNLICENSE) file.\r\n\r\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/pluma/obs/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}